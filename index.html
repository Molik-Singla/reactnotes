<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>React Notes</title>
    <link rel="stylesheet" href="prism.css" />
    <link rel="stylesheet" href="style.css" />
    <script defer src="prism.js"></script>
    <script defer src="app.js"></script>
  </head>
  <body>
    <ol>
      <li>
        <h2><span class="serialNumber">ddddddddddd</span> JSX</h2>
        <pre><code class="language-js">// ğŸ‘‰ JSX means Javascript XML.
// ğŸ‘‰ It is 96% HTML and Rest Javasript.
// ğŸ‘‰ Javasript Expression are written under { Expression } ( Curly Braces ). 
// ğŸ‘‰ Expression is anything which return any Value.
// ğŸ‘‰ All HTML attributes and css styles in JSX are write using PascalCase. 

// ğŸ‘‰ JSX Expression -: 
<xmp><h1>Hello User , My age is {20 - 1}</h1></xmp>
// ğŸ‘‰ Some Changes from HTML -> JSX
    // ğŸ‘‰ 1) ğŸ‘ class -> className.
    // ğŸ‘‰ 2) ğŸ‘ for -> htmlFor.
    // ğŸ‘‰ 3) ğŸ‘ All self closing tags closed using /> rathar than >.
</code></pre>
      </li>

      <li>
        <h2><span class="serialNumber"></span> React Fragment</h2>
        <pre><code class="language-js">// ğŸ‘‰ We can return only one element from Functional Component.
// ğŸ‘‰ So either we use a div to enclose all code or using React Fragments.
// ğŸ‘‰ React Fragments does not add extra element like div.

// ğŸ‘‰ React Fragemnt -:
<xmp><React.Fragment>
    <h1>Hello</h1>
    <h2>Hello Again</h2> 
</React.Fragment></xmp>

// ğŸ‘‰ React.Fragment written is Optional , It is same as -: 
<xmp><>
    <h1>Hello</h1>
    <h2>Hello Again</h2> 
</></xmp></code></pre>
      </li>

      <li>
        <h2><span class="serialNumber"></span> Css Style</h2>
        <pre><code class="language-js">// ğŸ‘‰ We can add styles through className or,
// We can use Javascript Object to add inline styles.
// ğŸ‘‰ Property name must be in PascalCase.
// ğŸ‘‰ Simple values is treated as in pixels ( px ).
// ğŸ‘‰ Inline Styles -:
// ğŸ‘‰ ğŸ¤·â€â™€ï¸ It is *style* not styl e.
<xmp><h1 styl e = {fontSize : 12 or any Javascript Object}>Hello</h1></xmp></code></pre>
      </li>

      <li>
        <h2><span class="serialNumber"></span> Components</h2>
        <pre><code class="language-js">// ğŸ‘‰ We can divide our website into small pieces called Components.
// ğŸ‘‰ Component name must be PascalCase as Convention.
// ğŸ‘‰ It is a special Function.
// ğŸ‘‰ We have Class and Functional Components.
// ğŸ‘‰ Component Name must Start with Capital Letter as Convention.
// ğŸ‘‰ We may can pass attributes ( Called Props ) like in HTML.
// ğŸ‘‰ Functional Components -: 
    // ğŸ‘‰ Function Return JSX.
    // ğŸ‘‰ Use it as -:
<xmp><FunctionComponentName propName="Brock Lesnar" /></xmp>

// ğŸ‘‰ Component -:
<xmp>function NavBar(props){
    return(
        <h1>Hello Ji</h1>
    )
}</xmp>
</code></pre>
      </li>

      <li>
        <h2><span class="serialNumber"></span> Props</h2>
        <pre><code class="language-js">// ğŸ‘‰ Props is like attributes in HTML and parameters in Javascript Functions.
// ğŸ‘‰ It helps to pass data to Components.
// ğŸ‘‰ We can pass anything (functions , state etc ) using props.

// ğŸ‘‰ Passing Props -:
<xmp><FunctionComponentName propName="propvalue" /></xmp>

// ğŸ‘‰ Accept Props -:
// ğŸ‘‰ Here, props is a Javascript Object.
<xmp>function NavBar(props){
    return(
        // ğŸ‘‰ Using Props -: 
        <h1>Hello {props.propName}</h1>
    )
}</xmp></code></pre>
      </li>

      <li>
        <h2><span class="serialNumber"></span> map() and key prop</h2>
        <pre><code class="language-js">// ğŸ‘‰ When we use .map() method then it is necessary to pass ,
// key prop ( Exact key ) to the returning element from .map().
// ğŸ‘‰ key is anything unique. 
// ğŸ‘‰ Keys are essential for React to be able to keep track of each ,
// element that is being iterated over with the .map() function.

<xmp>myArr.map((elem , index) => {
    return <h1 key={index}>Hello</h1>
})</xmp></code></pre>
      </li>

      <li>
        <h2><span class="serialNumber"></span> Event Handling</h2>
        <pre><code class="language-js">// ğŸ‘‰ We can attach events on JSX elements only.
// ğŸ‘‰ By adding props ( Like onClick etc ).

// ğŸ‘‰ Prop name Must be camelCase.
// ğŸ‘‰ As a Naming Convention event function start with hanlde.
// ğŸ‘‰ Event Handling -: 
function handleClick(){
    console.log("Button Clicked !")
}
<xmp><button onClick={handleClick}>Click</button></xmp>

// ğŸ‘‰ Passing Arguments -:
    // ğŸ‘‰ 1) ğŸ‘ Way
    // ğŸ‘‰ Use function () => handleClick(agr1) (Or use simple function ) inside ,
    // onClick={} ( It is hard to write in notes hope u understand).
    <xmp>< button onClick={}</button>}>Click< /button></xmp>

    // ğŸ‘‰ 2) ğŸ‘ Way
    // ğŸ‘‰ Use bind() (){this.handleClick.bind(this , arg1))} inside onClick={}
    <xmp>< button onClick={}</button>}>Click< /button></xmp>
</code></pre>
      </li>


      <li>
        <h2><span class="serialNumber"></span>Hooks</h2>
        <pre><code class="language-js">// ğŸ‘‰ Hooks allow function components to have access to state and other React features.
// ğŸ‘‰ Hooks allow us to "hook" into React features such as state and lifecycle methods.

// ğŸ‘‰ Rules for Hooks -: 
    // ğŸ‘‰ 1) ğŸ‘ Always write it inside Component ( At Top of a Component ).
    // ğŸ‘‰ 2) ğŸ‘ Directly import hooks or use using React.hookName.
    // ğŸ‘‰ 3) ğŸ‘ Don't Call hooks inside loop, nested functions and conditionals.</code></pre>
      </li>

      <li>
        <h2><span class="serialNumber"></span> useState() Hook and state</h2>
        <pre><code class="language-js">// ğŸ‘‰ state allow us to change certain value in component.
// ğŸ‘‰ When state changes , Components re-renders ( Which makes React Powerful without Page Loads ).

import React , {useState} from 'react'

const [count , setCount] = useState(InitialValue) // ğŸ‘‰ Or React.useState()
// ğŸ‘‰ InitialValue is of any DataType.
// ğŸ‘‰ We cannot directly change the state variable ( Like here count ) ,
// We need to use setter function ( Like here setCount ) to change state variable.
// ğŸ‘‰ As a Naming Convention setter function start with set. 

// ğŸ‘‰ Change State -:
    setCount( anyValue )  // ğŸ‘‰ It enhances to re-render the component.

// When we pass function to useState only runs First Time whether,
// Simple value runs on every Re-Render.
// Pass Function is need when we want to do hard computations in it
const [count , setCount] = useState(() => {
    console.log("Render Only First Time")
    return initialValue
})</code></pre>
      </li>

      <li>
        <h2><span class="serialNumber"></span> useContext() Hook</h2>
        <pre><code class="language-js">// ğŸ‘‰ 1) ğŸ‘ What is context and why we need it ?
// ğŸ‘‰ Ans - It us used to pass states / props directly to any child in a hieraracly, 
// without this we need to pass data in order wise and it is so difficuilt like -:

// ğŸ‘‰ Parent -> Child1 -> Child2 -> Child3 , We need to pass Data from : Parent -> Child3 
// ğŸ‘‰ without context we need to passs data to Child1 then Child2 and then Child3.
// ğŸ‘‰ Passing the props to all middleChild called Prop Drilling.

// ğŸ‘‰ To use context we need to perform 3 Steps -:
    // ğŸ‘‰ 1) ğŸ‘ createContext() ( In Parent )
    // ğŸ‘‰ 2) ğŸ‘ Producer ( In Parent )
    // ğŸ‘‰ 3) ğŸ‘ Consumer ( In Child using useContext Hook )

// ğŸ‘‰ In Parent create Context-:
const fName = createContext( defaultValue )
function App(){
    const [count , setCount] = useState(0)
    return (
        // ğŸ‘‰ value is important ( Exact ) and b/w this Provider all have access to fName Context.
        // ğŸ‘‰ To use [count , setCount] ,  we can destructure it later.
        <xmp><fName.Provider value={[count , setCount]}>
            <Child3 />
        </fName.Provider></xmp>
    )
}
export {fName}
    
// ğŸ‘‰ In Child Access Context -:
import {useContext} from react
import {fName} from ''

function Child3(){
    const [count , setCount] = useContext(fName)
    return(
        // ğŸ‘‰ Here use it.
    )
}

// ğŸ‘‰ In Context API the consumer part is tooo lengthy ,
// Thats why we use useContext hook in consumers.
</code></pre>
      </li>

      <li>
        <h2><span class="serialNumber"></span> useEffect() Hook</h2>
        <pre><code class="language-js">// ğŸ‘‰ It is used to perform extra tasks ( called Side-Effects ).
// ğŸ‘‰ Side effects means reach into the outside world. Like fetching data from an API ,
// or working with the DOM.

// ğŸ‘‰ useEffect take 1st parameter as Callback Function ( Called effect ) and 2nd parameter 
// ğŸ‘‰ ( Optional ) array.

// ğŸ‘‰ Callback function runs after every re-render ( if no dependencies is passed ).
// ğŸ‘‰ Callback cannot be an async Function.
// ğŸ‘‰ To run it only 1st re-render, pass 2nd parameter an Empty Array.
// ğŸ‘‰ Or re-render depends on certain states then pass state in 2nd parameter array ( with dependencies list ) .

import {useEffect} from react

function App(){
    useEffect(() => {
        // ğŸ‘‰ Do whatever u Want.
    },[] or [state1 , state2])
    return <xmp><h1>Hello</h1></xmp>
}

// ğŸ‘‰ Cleanup Function in useEffect -: 
// ğŸ‘‰ If we return a Function from useEffect then is work as Cleanup.
// ğŸ‘‰ It help to clean previous state of useEffect Like -:
// ğŸ‘‰ If we attach resize event on window then we will remove it ,
// in cleanup function from effecient memory usage.</code></pre>
      </li>

      <li>
        <h2><span class="serialNumber"></span>Forms</h2>
        <pre><code class="language-js">// ğŸ‘‰ It is bit more complex to handle forms.
// ğŸ‘‰ There are 2 types of forms
    // ğŸ‘‰ 1) ğŸ‘ Controlled Components.
    // ğŸ‘‰ 2) ğŸ‘ UnControlled Components ( useRef Hook and ref ).

// ğŸ‘‰ Controlled Components -:
// ğŸ‘‰ Here we need to set value , onChange .
// ğŸ‘‰ To handle Complex ( or More ) inputs ( or Components ) we use name attribute.

// ğŸ‘‰ To save us from many states we use one state with an object.
const [first, setfirst] = useState({
    f_name: "",
    sure: true,
    job: "employed",
    color: "",
});

// ğŸ‘‰ Rather than write many functions, we write one function for all inputs.
function handleOnChange(evt) {
    // ğŸ‘‰ For Checkbox ( type , checked need only for Checkbox ) we need to check here
    const { name, value, type, checked } = evt.target;
    setfirst((prev) => {
        return { ...prev, [name]: type === "checkbox" ? checked : value };
    });
}
<xmp><div>
    // ğŸ‘‰ input and textarea are works Same.( Access value in State)
    <input type="text" name="f_name" placeholder="Enter First Name" 
    onChange={handleOnChange} value={first.f_name}/>

    // ğŸ‘‰ checkbox makes differ ( Access T/F in State )
    <input type="checkbox" name="sure" onChange={handleOnChange} checked={first.sure} />

    // ğŸ‘‰ radio makes differ ( Access value in State)
    <input type="radio" name="job" onChange={handleOnChange} id="employed" value="employed" />
    <label htmlFor="employed">Employed</label>
    <input type="radio" name="job" onChange={handleOnChange} id="unemployed" value="unemployed" />
    <label htmlFor="unemployed">Unemployed</label>

    // ğŸ‘‰ dropdown makes differ ( Access value in State ).
    <select name="color" value={first.color} onChange={handleOnChange}>
        <option value="">--Choose--</option>
        <option value="green">green</option>
        <option value="blue">blue</option>
    </select>
</div></xmp></code></pre>
      </li>

      <li>
        <h2><span class="serialNumber"></span>Conditional Rendering</h2>
        <pre><code class="language-js">// ğŸ‘‰ Using -:
    // ğŸ‘‰ 1) ğŸ‘ if / else 
    // ğŸ‘‰ 2) ğŸ‘ Ternary Operator  with states
    // ğŸ‘‰ 3) ğŸ‘ Short Circuit Operator or with states

// ğŸ‘‰ 1) ğŸ‘ Short Circuit Operator ( && , || ) or with states -:

// ğŸ‘‰ Can change state to show - hide Elements.
const [shown, setShown] = useState(true);

<xmp>{shown && <h1>I am Hidden</h1>}</xmp>

// ğŸ‘‰ 2) ğŸ‘ Ternary Operator or with states -: 

const [shown, setShown] = useState(true);

<xmp>{shown === false ? <h1>I am First</h1> : <h1>I am Second</h1>}</xmp>

// ğŸ‘‰ 3) ğŸ‘ if / else -: 
// ğŸ‘‰ It is not at that important but it work as usually but outside,
// the component.
</code></pre>
      </li>
      
      <li>
        <h2><span class="serialNumber"></span>useRef() Hook and ref</h2>
        <pre><code class="language-js">// ğŸ‘‰ useRef hook allows to directly create a reference to the DOM element in the functional component. 

// ğŸ‘‰ UnControlled Components -:
// ğŸ‘‰ It is used to handle UnControlled Components.
// ğŸ‘‰ useRef return an mutable object of property current.
// ğŸ‘‰ useRef take parameter for initialValue.
// ğŸ‘‰ Difference between useRef() and creating a {current: ...} object yourself is that useRef will,
// give you the same ref object on every render.
// ğŸ‘‰ Advantage -:
    // ğŸ‘‰ 1) ğŸ‘ Does Not Cause Re-renders.
    // ğŸ‘‰ 2) ğŸ‘ Accessing DOM Elements.
    // ğŸ‘‰ 3) ğŸ‘ *Tracking State Changes.

// ğŸ‘‰ Uses -: 
    // ğŸ‘‰ 1) ğŸ‘ When we want to know how many times aut Component renders ,
    // cannot use states as it create infinite loop for this work.

import {useRef} from 'react'

const input_value = useRef(null);
function handle() {
    console.log(input_value.current.value);
}
// ğŸ‘‰ ref attribute gave reference to the reference variable.
<xmp><input type="text" ref={input_value} />
<button onClick={handle}>Submit</button></xmp></code></pre>
      </li>

      <li>
        <h2><span class="serialNumber"></span>React-Router v6</h2>
        <pre><code class="language-js">// ğŸ‘‰ We can change the pages on our site without reload the page ,
// Using react-router.

// ğŸ‘‰ 1) ğŸ‘ install react-router
<xmp>npm install react-router-dom@6</xmp>

// ğŸ‘‰ 2) ğŸ‘
import { 
    BrowserRouter, 
    Routes, Route , 
    Link , 
    NavLink , 
    useParams , 
    useNavigate ,
    Navigate
} from 'react-router-dom';

// ğŸ‘‰ Wrap main data b/w  BrowserRouter and then b/w Routes.
<xmp>function App() {
    return (
        <BrowserRouter>  // Syntax Must
            <Routes>     // Syntax Must
                <Route path='/' element={<Home />} />
                <Route path='about' element={<About />} />
                <Route path='products' element={<Products />} />
                // ğŸ‘‰ Nested Routes
                <Route path='course' element={<Products />} > 
                    <Route path='react' element={<React />} />
                </Route>
                // ğŸ‘‰ URL params ( :productId is a URL parameter )
                <Route path='products/:productId' element={<SingleProduct />} />
                // ğŸ‘‰ For Error Page
                <Route path='*' element={<Error />} />
            </Routes>
        </BrowserRouter>
    );
}</xmp>
// ğŸ‘‰ path defines the path in url.
// ğŸ‘‰ element defines which Component we want to render at a specify path.
// ğŸ‘‰ We can also define JSX in element.
// ğŸ‘‰ * We can write Route as self closing or Open-Close tag.
    // ğŸ‘‰ Self closing working as default.
    // ğŸ‘‰ Open and Close tag help to define another Route with Parent Route.
    // ğŸ‘‰ Like if parent Route have path="/course" and child Route have path="react" then,
    // ğŸ‘‰ For course we go on "/course" and for react we go on "/course/react"

// ğŸ‘‰ 3) ğŸ‘ Rather than 'a' tag we use Link tag in react-router.
<xmp><Link to='/about' className='btn'>
    About
</Link></xmp>
// ğŸ‘‰ 'to' is used to define , at which path we wanna go.

// ğŸ‘‰ 4) ğŸ‘ For error page
// ğŸ‘‰ We use * as path if no path was matched then * path handles that.

// ğŸ‘‰ 5) ğŸ‘ NavLink ( For style Active Route )
// ğŸ‘‰ It is same as Link , But is used to style the Active Route ( In easy Way ).

// ğŸ‘‰ Its *style* not styled here 
< NavLink to='/about' styled ={({ isActive }) => {
        return { color: isActive ? 'red' : 'grey' };
    }}>
    Home
< / NavLink>

// ğŸ‘‰ Rather than styles we can also use className here like -:
className={({ isActive }) => (isActive ? 'link active' : 'link')}

// ğŸ‘‰ isActive is by default use in NavLink

// ğŸ‘‰ 6) ğŸ‘ useParams Hook, URL parameters 
import { useParams } from 'react-router-dom';

const { productId } = useParams();

// ğŸ‘‰ 7) ğŸ‘ useNavigate Hook, To Navigate one page to another
// ğŸ‘‰ Like we want to Navigate user to Home after Successfull Login.
// ğŸ‘‰ We can use it on any click or event.
const navigate = useNavigate();

navigate('/Home');
navigate(-1); // go one page back
navigate(2); // go two page forward


// ğŸ‘‰ 8) ğŸ‘ Navigate Component 
// ğŸ‘‰ It is a component which help to navigate back.
return < Navigate to="/" />;

// 9) ğŸ‘ Protected Route
<xmp><ProtectedRoute user={user}>
    <Dashboard user={user} />
</ProtectedRoute></xmp>

<xmp>import { Navigate } from 'react-router-dom';
    const ProtectedRoute = ({ children, user }) => {
      if (!user) {
        return <Navigate to='/' />;
      }
      return children;
    };
export default ProtectedRoute;</xmp>
</code></pre>
      </li>


      <li>
        <h2><span class="serialNumber"></span>Custom Hooks</h2>
        <pre><code class="language-js">// ğŸ‘‰ Enhance reusibility of the Function.
// ğŸ‘‰ Like I have to use below Code in differ Components -: 
useEffect(() => {
    fetch("https://jsonplaceholder.typicode.com/todos")
      .then((res) => res.json())
      .then((data) => setData(data));
 }, []);

// ğŸ‘‰ So I will make my Custom Hook.
// ğŸ‘‰ Custom Hooks always starts with "use" as Convention,
// And call is as Simple Function.

// ğŸ‘‰ Custom Hook Example -: 
const useFetch = (url) => {
    const [data, setData] = useState(null);
    useEffect(() => {
      fetch(url)
        .then((res) => res.json())
        .then((data) => setData(data));
    }, [url]);
    return [data]; // ğŸ‘‰ Optional
};

// ğŸ‘‰ Calling Custom Hook -: 
const [data] = useFetch("https://jsonplaceholder.typicode.com/todos");
</code></pre>
      </li>


      <li>
        <h2><span class="serialNumber"></span>useReducer() Hook</h2>
        <pre><code class="language-js">// ğŸ‘‰ Work same as useState Hook.
// ğŸ‘‰ But its is usefull for managing complex states in Large Applications.
// ğŸ‘‰ It is also usefull when we want to do more operations with specify state.

EventHandler 
    ğŸ”½
  Dispatch ( Generally contain "type" and "payload" )
    ğŸ”½
  Reducer  ( Function which handle all Actions )
    ğŸ”½
State Update ( Then re-render Component )

// ğŸ‘‰ 2) ğŸ‘ Reducer Function
function reducer(state, action) {
    // ğŸ‘‰ Put if else Statements or switch Statement.
    // ğŸ‘‰ We can handle any number of action as we want.
    if (action.type === "add") return [...state, action.payload];
    if (action.type === "del") return [state.filter((elem) => elem !== action.payload)];
}
// ğŸ‘‰ 1) ğŸ‘ 
// ğŸ‘‰ const [state , dispatch] = useReducer(reducer , initialValue)  // ğŸ‘‰ Convention
const [todos, dispatch] = useReducer(reducer, []);


// ğŸ‘‰ 3) ğŸ‘ Calling Dispatch Function with type and payload.  
<xmp><button-onClick={() => dispatch({ type: "add", payload: "Buy Apples" } ) }>Inc< /button></xmp>
<p>{todos.map((elem, ind) => elem)}</p>    
</code></pre>
      </li>
    </ol>
  </body>
</html>
